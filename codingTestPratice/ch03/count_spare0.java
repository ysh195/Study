package ch03;

import java.util.Scanner;

/*
 * 문제 :
 * N개의 수 A1, A2, ..., AN이 주어졌을 때 연속된 부분의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.
 * 즉, Ai + ... + Aj(i <= j)의 합이 M으로 나누어 떨어지는 (i,j)쌍의 개수를 구하시오. 
 * 
 * 입력 :
 * 1번째 줄에 N과 M(1 <= N <= 10^6, 2 <= M <= 10^3),
 * 2번째 줄에 N개의 수 A1, A2, ..., AN이 주어진다. (0 <= Ai <= 10^9)
 * 
 * 출력 :
 * 1번째 줄에 연속된 부분의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.
 */

/*
 * 풀이 :
 * 1. N, M을 입력 받고, 제한에 맞게 조정한다.
 * 2. 중간에 M만큼의 차이가 발생하는 횟수를 카운트하기 위한 count와 M만큼 차이가 있는지를 체크할 D를 준비한다.
 * 3. for문을 통해 아래를 N번 반복한다.
 * --------------------------------------
 * ======================================
 * 3-1. 이 문제는 각 "연속된" 부분합 중 M의 배수의 갯수를 묻고 있다. "연속된"이 포인트다.
 * 3-1-1. 부분합 = 전체합[b] - 전체합[a] (단, b >= a)이고, 결국 각 구간 사이의 차이 D가 M의 배수인 횟수가 몇 번인지 카운트하면 된다.
 * 3-1-2. 그렇다면 숫자 D에 입력 받은 숫자를 더하다가, D가 M의 배수가 된 순간 D = 0으로 초기화하면서 count를 늘리는 것으로 계산할 수 있다.
 * 3-1-3. 또, D가 M의 배수라면, D1, D2, D3, ... 역시 M의 배수가 된다.
 * 		전체합[b] - 전체합[a] = M의 배수라면...
 * 		(전체합[b1] - 전체합[a]), (전체합[b2] - 전체합[a]), (전체합[b3] - 전체합[a])... 역시 M의 배수이기 때문에, [a에 들어갈 수 있는 숫자의 갯수] * [b에 들어갈 수 있는 숫자의 갯수]만큼의 조합이 가능한 것이다.
 * 		여기서 [b에 들어갈 수 있는 숫자의 갯수] = count이고, [a에 들어갈 수 있는 숫자의 갯수] = (count - 1)이다.
 * 		(i,j)쌍 = [a에 들어갈 수 있는 숫자의 갯수] * [b에 들어갈 수 있는 숫자의 갯수]이지만, 중복을 피하기 위해 /2를 할 필요가 있다.
 * 3-1-4. 따라서 D가 M의 배수였던 횟수를 카운트한, count를 사용해서 count*(count-1)/2를 계산하면 (i,j)쌍의 갯수가 나온다.
 * 3-1-5. 한편, 문제는 "부분의 합이 M으로 나누어 떨어지는" 것을 조건으로 삼고 있으므로, (a = b)인 상황도 포함한다.
 * 		부분합 = 전체합[b] - 전체합[a] = 전체합[b] - 전체합[b] = 0
 * 		0 % M = 0
 * 		인 상황까지 포함한다. 이때, b <= N 이므로, a = b인 상황은 총 N번 발생한다.
 * 3-1-6. 따라서 [count*(count-1)/2 + N]이 이 문제의 답이다.
 * =======================================
 * 3-2. 숫자가 10^9 범위이기 때문에 long 타입으로 입력 받고, 제한에 맞게 조정한다.
 * 3-3. D에 입력 받은 숫자를 저장한다.
 * 3-4. 만약 D가 0이 아니면서 D의 배수라면 D=0으로 초기화하고 count를 늘린다.
 * ---------------------------------------
 * 4. count*(count-1)/2 + N)을 출력한다.
 */

/*
 * 그림이 이클립스에서는 멀쩡하게 나오는데, 깃허브에서는 깨짐
 * 전체합[a]는 가장 앞에 있는 전체합[a]를 말한다.
 * 
 * |------------------------------ M * (x1 + x2 + x3 + ... + xN) -------------------------------|
 * 
 * 				|------------------------------ M * (x2 + x3 + ... + xN) -----------------------|
 * 																
 * 											|--------------- M * (x3 + ... + xN) ---------------|
 * 
 * 				|							|					|								|
 *				|							|					|								| 
 *				|							|					|								| 
 *	  x1 * M	|			x2 * M			|		x3 * M	  ....			xN * M				| 
 *		= D		|			 = D1			|		= D3	  ....   		= DN				|
 * |============|===========================|===================|===============================|======
 * 전체합[a]	  전체합[b1]                  전체합[b2]            전체합[b3]....				    전체합[bN]
 * 
 * |----------------------------------------- N = count ----------------------------------------|
 * 
 * 이처럼 전체합[bN]은 count만큼의 M의 배수가 되는 경우의 수를 가지고 있다.
 * 마찬가지로 전체합[bN-1]은 count만큼의 M의 배수가 되는 경우의 수를 가지고 있기 때문에 이것들을 모두 더한다면
 * (x = 1 >> count), 첫째항 a = 0, 공차 d = 1인 등차수열과 같으므로, count*(count-1)/2 혹은 for(int i=1; i<=count; i++){ result += i; }로 계산할 수 있다.
 * 제한 시간을 초과하지 않으려면 for문의 사용을 자제해야 하므로, 전자로 계산한다. 
 */


// 진짜 코딩 실력하고는 무관한 수학 문제인데? 

public class SumSpare {

	public static void main(String[] args) {
		Scanner sc1 = new Scanner(System.in);
		Scanner sc2 = new Scanner(System.in);
		Scanner sc3 = new Scanner(System.in);
		
		int N = sc1.nextInt();
		N = Math.min(1000000, Math.max(1, N));
		
		int M = sc2.nextInt();
		M = Math.min(1000, Math.max(1, M));
		
		int count = 0;
		long D = 0;
		
		for(int i=0; i<N; i++) {
			long num = sc3.nextLong();
			num = Math.min(1000000000, Math.max(0, num));
			D += num;
			
			if((D != 0) && ((D % M) == 0)) {
				D = 0;
				count++;
			}
		}
		
		System.out.println(count*(count-1)/2 + N);

	}

}
