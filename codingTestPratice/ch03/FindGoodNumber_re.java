package ch03;

import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

//contains를 쓰면 for문 없이 간결하게 되는 줄 알았는데, contains 사용 시 문제가 있음을 깨달아서 다시 풀이함.

/*
 * 문제 :
 * 주어진 N개의 수에서 다른 두 수의 합으로 표현되는 수가 있다면 그 수를 '좋은 수'라고 한다. N개의 수 중 좋은 수가 총 몇 개인지 출력하시오.
 * 
 * 입력 :
 * 1번째 줄에 수의 개수 N(1 <= N <= 2000)이,
 * 2번째 줄에 N개의 수의 값(Ai)이 주어진다. (Ai는 |Ai| <= 1000000000인 정수)
 * 
 * 출력 : 
 * 좋은 수의 개수를 출력한다.
 */

/*
 * 풀이 :
 * 시간 제한 2초에 N이 2000 이하이기 때문에 2중 for문까지는 가능하다.
 * 1. 숫자 N을 입력 받고 제한 범위에 맞게 조정한다.
 * 2. 숫자들을 N번 만큼 입력 받고, 각각을 제한 범위에 맞게 조정한다.
 * 3. 입력 받은 숫자들을 내림차순으로 정렬하고, longArr 배열에 저장한다.
 * 4. 좋은 수의 갯수를 저장할 count를 준비한다.
 * 5. for문을 다음과 같이 반복한다.
 * --------------------------------------------------------------------
 * 5-1. 조건상으로는 N = 1인 경우도 가능하지만, 좋은 수 = 두 수의 합이기 때문에 N은 최소 2 이상의 수이다. 만약 1 이하라면 for문이 시작하지도 못하고 바로 count = 0으로 출력된다.
 * 		p1 = i+1, p2 = 1, p3 = 0 를 준비한다. 각자 배열의 인데스값으로 사용될 것이며,
 * 		p1 = i+1이기 때문에 longArr의 범위를 초과할 우려가 있다. 따라서 for문의 반복 횟수를 (longArr.length - 1)로 제한한다.
 * 		한편, |Ai| <= 1000000000인 정수이기 때문에 Ai에는 0도 포함된다.
 * 		따라서 longArr[0] = 0 또는 longArr[1] = 0 일 경우,
 * 		longArr[0]과 longArr[1]은 자기 자신을 좋은 수로 가질 수 있기 때문에
 * 		longArr[1] == longArr[1] + longArr[0]
 * 		이 성립하므로, p1 = i+2가 아니라 i+1부터 시작한다.
 * 5-2. for문 내부에 while문을 사용한다. 2중 for문(2000*2000)까지는 괜찮지만, 3중 for문(2000*2000*2000)은 조건상 불가능하다.
 * 		따라서 2중으로 하되 while을 사용하여 2000*(2000+a)로 계산한다.
 * 5-3. 다음과 같이 while문을 반복한다.
 * ====================================================================
 * 5-3-1. longArr[p1] == longArr[p2] + longArr[p3]로 현재 각 숫자의 합이 좋은 수에 해당하는지 판단한다.
 * 		 - 좋은 수에 해당한다면, count를 늘리고, 이번 회차의 반복을 중단한다.
 * 		 - 그렇지 않다면, 다음으로 진행한다.
 * 5-3-2. 포인트들의 중간에 위치해 있는 p2를 기준으로 판단한다.
 * 		- 맨 뒤에 위치해 있는 p3가 p2의 바로 뒤에 있다면
 * 			- 그리고 p1이 p2의 바로 앞에 있거나 겹쳐 있다면, 이번 회차의 반복을 중단한다.
 * 			  더 이상 이동할 자리가 없다. 이번 회차의 위치가 좋은 수에 해당하지 않음은 앞에서 이미 확인되었다.
 * 			- p1과 p2와의 차이가 1칸 이상(= 숫자로는 2 이상)이라면(= 이동할 여유가 있다면), 앞으로 이동한다.
 * 5-3-3. 여기까지 왔다면 p2가 이동했을 것이다. 그렇지 않았다면(= p2에게 이동할 자리가 없었다면) 이미 종료되었을 것이다.
 * 		 p2가 이동했으니 현재 각 숫자의 합이 좋은 수에 해당하는지 판단한다.
 * 		 - 좋은 수에 해당한다면, count를 늘리고, 이번 회차의 반복을 중단한다.
 * 		 - 그렇지 않다면, p3를 앞으로 이동시키고 다음으로 진행한다.
 * =====================================================================
 * 5-4. 이와 같은 방법으로 매 반복마다 p1을 통해 구하고자 하는 값이 무엇인지 고정시키고,
 * 		while문 내부에서 포인터 2개를 이동시킴으로써 숫자 2개의 조합을 만들고, 그것의 합이 p1이 가리키고 있는 값인지 체크한다.
 * ---------------------------------------------------------------------
 * 6. count를 출력한다.
 */

public class FindGoodNumber_re {

	public static void main(String[] args) { // 시간 제한 2초에 N이 2000 이하이기 때문에 2중 for문까지는 가능.
		
		Scanner sc1 = new Scanner(System.in);
		Scanner sc2 = new Scanner(System.in);
		
		int N = sc1.nextInt();
		N = Math.min(2000, Math.max(1, N));
		
		long[] longArr = new long[N];
		for(int i=0; i<N; i++) {
			longArr[i] = sc2.nextLong();
			longArr[i] = (longArr[i] >= 0) ? Math.max(1000000000, longArr[i]) : Math.min(-1000000000, longArr[i]);
		}
		
		longArr = Arrays.stream(longArr).sorted().toArray();

		int count = 0;
		
		for(int i=0; i<longArr.length-1; i++) {
			
			int p1 = i+1, p2 = 1, p3 = 0;

			while(true) {
				
				if(longArr[p1] == longArr[p2] + longArr[p3]) {
					count++;
					break;
				}
				else {
					
					if(p2 - p3 <= 1) { // 맨 뒤 포인터가 중간 포인터 바로 뒤에 있을 때
						if(p1 - p2 <= 1) { break; } // 그리고 중간 포인터도 맨 앞 포인터 바로 뒤에 있거나 겹쳐 있어서 더이상 움직일 수 없을 때는 멈춰라
						else { p2++; } // 하지만 움직일 수 있으면 움직여라
					}
					
					if(longArr[p1] == longArr[p2] + longArr[p3]) { // 일단 지금 상황을 판단 후
						count++;
						break;
					}
					else { p3++; } // 당첨 아니면 바로 움직여라
				}
				
			}
		}

		System.out.println(count);
		
	}

}
