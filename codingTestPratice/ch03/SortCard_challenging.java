package ch03;

import java.util.Scanner;

// 문제의 난이도가 너무 쉬워서 스스로 코드 실행 제한 시간을 본래보다 낮춰서 다시 풀음
// 원래는 컬렉션의 기본 기능을 이용하는 문제
// 정석적인 풀이는 같은 깃허브 내에 SortCard_basic로 저장되어 있다.

/*
 * 코드실행 제한 시간 : (변경 전) 2초 > (변경 후) 0.1초
 * 
 * 문제 :
 * N장의 카드가 있다. 각각의 카드는 차례로 1에서 N까지의 번호가 붙어 있으며, 1번 카드가 가장 위, N번 카드가 가장 아래인 상태로 놓여 있다.
 * 이제 다음과 같은 동작을 카드가 1장 남을 때까지 반복한다.
 *  - 먼저 가장 위에 있는 카드를 제거한다. 제거된 카드는 다시 카드 뭉치에 추가되지 않는다.
 *  - 그 다음 가장 위에 있는 카드를 가장 아래에 있는 카드 밑으로 옮긴다.
 * 
 * 예를 들어 N = 4일 때
 * 카드는 가장 위에서부터 1, 2, 3, 4의 순서대로 놓여 있다.
 * 1을 버리면 2, 3, 4가 남는다. 2를 가장 아래로 옮기면 순서가 3, 4, 2가 된다.
 * 3을 버리면 4, 2가 남고, 4를 가장 아래로 옮기면 순서가 2, 4가 된다.
 * 마지막으로 2를 버리면 4만 남는다.
 * 
 * 입력 :
 * 1번째 줄에 정수 N이 주어진다. (1 <= N <= 500,000)
 * 
 * 출력 :
 * 1번째 줄에 남는 카드의 번호를 출력한다.
 * 
 * 풀이 :
 * 
 * 본격적인 풀이에 앞서 문제를 정리한다.
 * 
 * 위에 제시된 일련의 절차를 거치면, 현재 카드 중 홀수 순번에 있는 카드는 모두 버리고, 짝수 순번에 있는 카드만 남는다.
 * 카드 2장 중 앞에 있는 것은 버려지고 뒤에 있는 카드만 남기 때문에, 이러한 과정에 따르면 결국 맨 뒤에 있던 카드가 선택된다.
 * 따라서 주목해야 할 것은 '맨 뒤에 있는 카드가 무엇인가'이다. 그리고 그 계산을 위해 필요한 맨 앞에 있는 숫자까지만 알면 그 이상은 필요가 없다. 
 * 
 * 그리고 여기 변수가 존재한다.
 * 만약 현재 카드의 갯수가 홀수라면, 그 시점에 맨 뒤에 있는 카드와 맨 앞에 있는 카드가 쌍을 이루어 다시 과정을 진행한다.
 * 그 경우, 원래 맨 뒤에 있던 카드는 제거되고, 맨 앞에 있던 카드가 맨 뒤로 추가된다.
 * 
 * 따라서 현재 카드의 갯수가
 *  - 짝수이면 맨 앞의 카드는 2번째 카드로 바뀌고, 맨 뒤의 카드는 그대로 유지된다.
 *  - 홀수이면 맨 앞의 카드는 4번째였던 카드로 바뀌고, 맨 뒤의 카드는 맨 앞에서 2번째 카드로 바뀐다.
 * 
 * 홀수인 상황에 대해 부가적인 설명을 덧붙인다.
 * a. 일련의 절차를 한 번 거치고 나면, 첫 번째에 있던 카드은 버려지고, 두 번째에 있던 카드가 맨 앞자리를 차지한다.
 * b. 이 상태에서 맨 뒤에 있는 카드가 자신과 절차를 진행할 짝이 없으니, 맨 앞에 있는 카드와 짝을 이루는 것이고,
 *    이 시점에는 이미 원래 두 번째에 있던 것이 맨 앞자리로 이동한 뒤이기 때문에
 *    맨 뒤의 카드는 버려지고 원래는 2번째였던 카드가 맨 뒤로 이동한다.
 * c. 한편, 일련의 절차를 거치면서 3번째 카드는 사라지고 본래 4번째였던 카드가 그 자리를 차지한다.
 * e. 그 상태에서 2번째였던 카드가 앞으로 이동했으니 2번째 자리가 비워지면서
 * f. 자연스럽게 4번째였던 카드가 2번째 자리까지 올라간다.
 * g. 또, 맨 앞의 카드가 맨 뒤의 카드와 절차를 거치면서 맨 뒤로 이동하였으니, 결과적으로 앞에서 4번째였던 카드가 맨 앞까지 오게 되는 것이다.
 * 
 * 이것을 시각적으로 표현하면...
 * 다음과 같은 5장의 카드가 있다.
 * A B C D E
 * 
 * 이것들이 한 번의 절차를 거치면
 * B D / E
 * 인데 E는 자신과 절차를 진행할 짝이 없어서 어쩔 수 없이 바로 앞에 있는 B와 짝을 이룬다.
 * 
 * D B
 * 이 과정에서 E는 버려지고, B는 맨 뒤로 이동한다.
 * 그러면 결과적으로 4번째에 있던 카드 D는 맨 앞으로 이동하고, 2번째에 있던 카드 B는 맨 뒤로 이동한다.
 * 
 * 이러한 절차의 흐름을 확인해보자.
 * 
 * N = 16일 때,
 * 카드는 아래와 같이 배치된다.
 * 
 * 1회차 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] (카드 : 16장)
 * 2회차	[	2,    4,    6,    8,    10,     12,     14,     16] (카드 : 8장)
 * 3회차 [         4,          8,            12,             16] (카드 : 4장)
 * 4회차 [                     8,                            16] (카드 : 2장)
 * 5회차 [                                                   16] (카드 : 1장)
 * 최종 결과 : 16
 * 
 * 이처럼 현재 카드의 갯수가 짝수이면 가장 큰 수만 남는다.
 * 
 * N = 10일 때,
 * 1회차 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (카드 : 10장)
 * 2회차 [   2,    4,    6,    8,    10] (카드 : 5장)
 * 3회차 [         4,          8,    10] (카드 : 3)
 * >> 4와 10이 쌍을 이루어 계산하는 과정에서 10은 버려지고, 4는 맨 뒤로 이동한다. 
 *      [                     8,    4] (카드 : 2) 이것과 바로 위는 모두 같은 3회차 내에서 발생한 변동사항이다.
 * 4회차 [                           4] (카드 : 1)
 * 8이 버려지는 순간 카드가 1장이 되어 절차가 종료된다.
 * 최종 결과 : 4
 * 
 * 이번에는 N = 16 케이스를 통해 각 회차와 그 회차 내의 숫자들 사이의 상관관계를 확인한다.
 * 같은 회차 내에서 남아 있는 숫자들은 (마지막 숫자를 제외하고는) 각각 + (2 ^ (해당 회차 - 1))의 차이를 가지고 있다.
 * 쉽게 말해, 1회차는 1씩 차이 나고, 2회차는 2씩, 3회차는 4씩 차이난다.
 * 그런데 N = 10 케이스의 3회차에서는 상황이 다르다.
 * 숫자 8 뒤에 4가 있으니 숫자들 사이의 상관관계가 깨진 것일까?
 * 그렇지 않다. 4가 뒤로 옮겨졌을 뿐, 여전히 자기와 자기 다음으로 큰 수의 차이가 4임이 지켜지고 있다.
 * 
 * 또, 일련의 절차 속에서 발생하는 모든 변동사항은 없던 숫자가 생겨나는 것이 아니며, 카드의 순서 변경에 불과함을 알 수 있다.
 * 
 * 이러한 흐름에 유의하며 이제 문제를 풀어보자.
 * 
 * 1. 숫자 N을 입력 받고, 제한된 범위에 맞추어 조절한다.
 * 2. 현재 몇 회차가 진행되는지를 기록할 cycle_counter를 준비한다.
 * 3. 계산 편의를 위해 첫번째 값을 저장할 first와, 주목해야 할 마지막 값을 저장할 last를 준비한다.
 *    시작 시점에서 가장 앞에 있는 숫자는 1이고, 가장 뒤에 있는 수는 N이니, first = 1, last = N으로 초기값을 설정한다.
 * 4. while문을 다음과 같이 실행한다.
 * 4-1. N이 2이상이면(N을 2로 나눌 수 있다면) 계속 진행한다.
 * 4-2. 현재 회차를 기록한다.
 * 4-3. 가장 앞에 있는 숫자를 버린다.
 *      = 2번째 숫자였던 것이 1번째 숫자가 된다.
 *      = 모든 숫자 사이의 차이는 [2 ^ (해당 회차 - 1)] 이므로,
 *        현재 가장 앞에 있는 숫자인 first에 [2 ^ (해당 회차 - 1)]을 더하면 그 다음 순서의 숫자가 된다.
 * 4-4. 만약 현재 N이 홀수라면
 * 4-4-1. 가장 앞에 있는 숫자를 가장 뒤로 옮긴다.
 *       = last에 first를 저장한다.
 * 4-4-2. 현재 first에 입력된 값은 2번째 순서에 있는 카드의 값이다.
 *        이를 4번째 순서에 있는 카드의 값으로 변경하기 위해서는 + 2 ^ (해당 회차 - 1) * 2를 하면 된다.
 *        2 ^ (해당 회차 - 1) * 2
 *        = 2^(해당 회차 - 1) * 2^1
 *        = 2^(해당 회차 - 1 + 1)
 *        = 2^해당 회차
 *        이므로, first에 [2^해당 회차]를 더해준다.
 * 4-5. N을 2로 나눈다. int타입이니까 소숫점은 자동으로 버린다.
 * 5. last의 값을 출력한다.
 */

// 매 회차마다 N을 2로 나누면서, N을 2로 나누는 게 가능한 횟수만큼만 반복문을 진행한다.
// N의 최댓값은 500,000이고, 500,000은 2로 18번 나눌 수 있기 때문에, 단 18번 안에 모든 계산이 끝난다.
// 참고로, 정석적인 방식으로 계산했을 때의 실행횟수는 100만 번으로, 0.1초가 소요된다.

public class SortCard_challenging {

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int N = sc.nextInt();
		N = Math.min(500000, Math.max(1, N));

		int cycle_counter = 0;
		int first = 1;
		int last = N;
		
		while(N>=2) {
			
			cycle_counter++;
			first += Math.pow(2, cycle_counter-1);
			if(N%2 == 1) {
				last = first;
				first += Math.pow(2, cycle_counter);
			}

			N = N/2;
		}
		
		System.out.println(last);
	}

}
